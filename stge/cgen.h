
//
// Copyright (c) 2008 Waync Cheng.
// All Rights Reserved.
//
// 2008/03/14 Waync created.
//

#pragma once

#include <sstream>

namespace stge {

class CodeGenerator
{
public:

  static bool generate(std::string const& filename, ScriptManager const& scm)
  {
    std::stringstream ss;
    if (!generateToStream(ss, scm)) {
      return false;
    }

    FILE *f = fopen(filename.c_str(), "wt");
    if (f) {
      std::string s = ss.str();
      fwrite(s.data(), s.size(), 1, f);
      fclose(f);
      return true;
    } else {
      return false;
    }
  }

  static bool generateToStream(std::ostream& ostream, ScriptManager const& scm)
  {
    ostream << "\n// script code generated by stge::CodeGenerator\n\n";

    ostream << "namespace stge_script_impl {\n\n";
    for (ScriptManager::const_iterator it = scm.begin(); scm.end() != it; ++it) {

      Script const& root = it->second;

      ostream << "void " << it->first << "(stge::ScriptManager& scm)\n";
      ostream << "{\n";
      ostream << "    using namespace stge;\n";
      ostream << "    Script " << it->first << ";\n";

      if (!generateToStream(ostream, root, it->first + ".sc")) {
        return false;
      }

      ostream << "    scm[\"" << it->first << "\"] = " << it->first << ";\n";
      ostream << "}\n\n";
    }

    ostream << "} // stge_script_impl\n\n";

    ostream << "void stgeLoadScript(stge::ScriptManager& scm)\n";
    ostream << "{\n";

    for (ScriptManager::const_iterator it = scm.begin(); scm.end() != it; ++it) {
      ostream << "    stge_script_impl::" << it->first << "(scm);\n";
    }

    ostream << "}\n";

    ostream << "\n// end of file\n";

    return true;
  }

  static bool generateToStream(std::ostream& ostream, Script const& sc, std::string const& tag)
  {
    for (std::list<Script>::const_iterator its = sc.sc.begin(); sc.sc.end() != its; ++its) {

      switch (its->type)
      {
      case Script::REPEAT:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::REPEAT, \""
          << its->param[0].exp
          << "\"));\n";
        if (!generateToStream(ostream, *its, tag + ".back().sc")) {
          return false;
        }
        break;

      case Script::OPTION:
        ostream
        << "    "
        << tag
        << ".push_back(Script(Script::OPTION, \""
        << its->param[0].exp
        << "\"));\n";
        if (!generateToStream(ostream, *its, tag + ".back().sc")) {
          return false;
        }
        break;

      case Script::FORK:
      case Script::CALL:
      case Script::FIRE:
        {
          static const char* scmd[] = {"FORK", "CALL", "FIRE"};
          ostream
            << "    "
            << tag
            << ".push_back(Script(Script::" << scmd[its->type - Script::FORK] << ", \""
            << its->param[0].exp
            << "\", \""
            << its->param[1].exp
            << "\", \""
            << its->param[2].exp
            << "\", \""
            << its->param[3].exp
            << "\", \""
            << its->param[4].exp
            << "\", \""
            << its->param[5].exp
            << "\", \""
            << its->param[6].exp
            << "\"));\n";
        }
        break;

      case Script::SLEEP:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::SLEEP, \""
          << its->param[0].exp
          << "\"));\n";
        break;

      case Script::DIRECTION:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::DIRECTION, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\"));\n";
        break;

      case Script::SPEED:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::SPEED, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\"));\n";
        break;

      case Script::CHANGEDIRECTION:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::CHANGEDIRECTION, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\", \""
          << its->param[2].exp
          << "\"));\n";
        break;

      case Script::CHANGESPEED:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::CHANGESPEED, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\", \""
          << its->param[2].exp
          << "\"));\n";
        break;

      case Script::CHANGEX:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::CHANGEX, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\", \""
          << its->param[2].exp
          << "\"));\n";
        break;

      case Script::CHANGEY:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::CHANGEY, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\", \""
          << its->param[2].exp
          << "\"));\n";
        break;

      case Script::CLEAR:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::CLEAR));\n";
        break;

      case Script::USERDATA:
        ostream
          << "    "
          << tag
          << ".push_back(Script(Script::USERDATA, \""
          << its->param[0].exp
          << "\", \""
          << its->param[1].exp
          << "\", \""
          << its->param[2].exp
          << "\", \""
          << its->param[3].exp
          << "\"));\n";
        break;
      }
    }
    return true;
  }
};

} // namespace stge

// end of cgen.h
